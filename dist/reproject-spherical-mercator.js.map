{
  "version": 3,
  "sources": [
    "../../../../../usr/local/lib/node_modules/browserify/node_modules/browser-pack/_prelude.js",
    "/home/gaganb/projects/geosquare/reproject-spherical-mercator/index.js",
    "/home/gaganb/projects/geosquare/reproject-spherical-mercator/node_modules/geojson-bbox/geojson-bbox.js",
    "/home/gaganb/projects/geosquare/reproject-spherical-mercator/node_modules/sphericalmercator/sphericalmercator.js"
  ],
  "names": [],
  "mappings": "AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})",
    "// reproject-spherical-mercator index.js\nvar SphericalMercator = require('sphericalmercator'),\n  bbox = require('geojson-bbox'),\n  sm = new SphericalMercator({size: 256});\nfunction projCoords(coords) {\n  return coords.map(function(coord) {\n    return sm.forward(coord);\n  });\n}\n\nvar reproject = function(g) {\n  var pg = {type: g.type};\n  if (g.type == 'Point') {\n    pg.coordinates = sm.forward(g.coordinates);\n  } else if (g.type == 'LineString' || g.type == 'MultiPoint') {\n    pg.coordinates = projCoords(g.coordinates);\n  } else if (g.type == 'Polygon' || g.type == 'MultiLineString') {\n    pg.coordinates = g.coordinates.map(function(part) {\n      return projCoords(part);\n    });\n  } else if (g.type =='MultiPolygon') {\n    pg.coordinates = g.coordinates.map(function(poly) {\n      return poly.map(function(part) {\n        return projCoords(part);\n      });\n    });\n  } else if (g.type == 'Feature') {\n    pg.geometry = reproject(g.geometry);\n    if (g.id) pg.id = g.id;\n    if (g.properties) pg.properties = g.properties;\n    if (g.bbox) pg.bbox = bbox(pg);\n  } else if (g.type == 'FeatureCollection') {\n    pg.features = g.features.map(function(f) {\n      return reproject(f);\n    });\n    if (g.bbox) pg.bbox = bbox(pg);\n  } else if (g.type == 'GeometryCollection') {\n    pg.geometries = g.geometries.map(function(geom) {\n      return reproject(geom);\n    });\n  } else {\n    throw new Error('Not a valid geojson');  \n  }\n  return pg; \n};\n\nmodule.exports = reproject;\n",
    "module.exports = function(gj) {\n  var coords, bbox;\n  if (!gj.hasOwnProperty('type')) return;\n  coords = getCoordinatesDump(gj);\n  bbox = [ Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY,\n      Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY,];\n  return coords.reduce(function(prev,coord) {\n    return [\n      Math.min(coord[0], prev[0]),\n      Math.min(coord[1], prev[1]),\n      Math.max(coord[0], prev[2]),\n      Math.max(coord[1], prev[3])\n    ];\n  }, bbox);\n};\n\nfunction getCoordinatesDump(gj) {\n  var coords;\n  if (gj.type == 'Point') {\n    coords = [gj.coordinates];\n  } else if (gj.type == 'LineString' || gj.type == 'MultiPoint') {\n    coords = gj.coordinates;\n  } else if (gj.type == 'Polygon' || gj.type == 'MultiLineString') {\n    coords = gj.coordinates.reduce(function(dump,part) {\n      return dump.concat(part);\n    }, []);\n  } else if (gj.type == 'MultiPolygon') {\n    coords = gj.coordinates.reduce(function(dump,poly) {\n      return dump.concat(poly.reduce(function(points,part) {\n        return points.concat(part);\n      },[]));\n    },[]);\n  } else if (gj.type == 'Feature') {\n    coords =  getCoordinatesDump(gj.geometry);\n  } else if (gj.type == 'GeometryCollection') {\n    coords = gj.geometries.reduce(function(dump,g) {\n      return dump.concat(getCoordinatesDump(g));\n    },[]);\n  } else if (gj.type == 'FeatureCollection') {\n    coords = gj.features.reduce(function(dump,f) {\n      return dump.concat(getCoordinatesDump(f));\n    },[]);\n  }\n  return coords;\n}\n",
    "var SphericalMercator = (function(){\n\n// Closures including constants and other precalculated values.\nvar cache = {},\n    EPSLN = 1.0e-10,\n    D2R = Math.PI / 180,\n    R2D = 180 / Math.PI,\n    // 900913 properties.\n    A = 6378137.0,\n    MAXEXTENT = 20037508.342789244;\n\n\n// SphericalMercator constructor: precaches calculations\n// for fast tile lookups.\nfunction SphericalMercator(options) {\n    options = options || {};\n    this.size = options.size || 256;\n    if (!cache[this.size]) {\n        var size = this.size;\n        var c = cache[this.size] = {};\n        c.Bc = [];\n        c.Cc = [];\n        c.zc = [];\n        c.Ac = [];\n        for (var d = 0; d < 30; d++) {\n            c.Bc.push(size / 360);\n            c.Cc.push(size / (2 * Math.PI));\n            c.zc.push(size / 2);\n            c.Ac.push(size);\n            size *= 2;\n        }\n    }\n    this.Bc = cache[this.size].Bc;\n    this.Cc = cache[this.size].Cc;\n    this.zc = cache[this.size].zc;\n    this.Ac = cache[this.size].Ac;\n};\n\n// Convert lon lat to screen pixel value\n//\n// - `ll` {Array} `[lon, lat]` array of geographic coordinates.\n// - `zoom` {Number} zoom level.\nSphericalMercator.prototype.px = function(ll, zoom) {\n    var d = this.zc[zoom];\n    var f = Math.min(Math.max(Math.sin(D2R * ll[1]), -0.9999), 0.9999);\n    var x = Math.round(d + ll[0] * this.Bc[zoom]);\n    var y = Math.round(d + 0.5 * Math.log((1 + f) / (1 - f)) * (-this.Cc[zoom]));\n    (x > this.Ac[zoom]) && (x = this.Ac[zoom]);\n    (y > this.Ac[zoom]) && (y = this.Ac[zoom]);\n    //(x < 0) && (x = 0);\n    //(y < 0) && (y = 0);\n    return [x, y];\n};\n\n// Convert screen pixel value to lon lat\n//\n// - `px` {Array} `[x, y]` array of geographic coordinates.\n// - `zoom` {Number} zoom level.\nSphericalMercator.prototype.ll = function(px, zoom) {\n    var g = (px[1] - this.zc[zoom]) / (-this.Cc[zoom]);\n    var lon = (px[0] - this.zc[zoom]) / this.Bc[zoom];\n    var lat = R2D * (2 * Math.atan(Math.exp(g)) - 0.5 * Math.PI);\n    return [lon, lat];\n};\n\n// Convert tile xyz value to bbox of the form `[w, s, e, n]`\n//\n// - `x` {Number} x (longitude) number.\n// - `y` {Number} y (latitude) number.\n// - `zoom` {Number} zoom.\n// - `tms_style` {Boolean} whether to compute using tms-style.\n// - `srs` {String} projection for resulting bbox (WGS84|900913).\n// - `return` {Array} bbox array of values in form `[w, s, e, n]`.\nSphericalMercator.prototype.bbox = function(x, y, zoom, tms_style, srs) {\n    // Convert xyz into bbox with srs WGS84\n    if (tms_style) {\n        y = (Math.pow(2, zoom) - 1) - y;\n    }\n    // Use +y to make sure it's a number to avoid inadvertent concatenation.\n    var ll = [x * this.size, (+y + 1) * this.size]; // lower left\n    // Use +x to make sure it's a number to avoid inadvertent concatenation.\n    var ur = [(+x + 1) * this.size, y * this.size]; // upper right\n    var bbox = this.ll(ll, zoom).concat(this.ll(ur, zoom));\n\n    // If web mercator requested reproject to 900913.\n    if (srs === '900913') {\n        return this.convert(bbox, '900913');\n    } else {\n        return bbox;\n    }\n};\n\n// Convert bbox to xyx bounds\n//\n// - `bbox` {Number} bbox in the form `[w, s, e, n]`.\n// - `zoom` {Number} zoom.\n// - `tms_style` {Boolean} whether to compute using tms-style.\n// - `srs` {String} projection of input bbox (WGS84|900913).\n// - `@return` {Object} XYZ bounds containing minX, maxX, minY, maxY properties.\nSphericalMercator.prototype.xyz = function(bbox, zoom, tms_style, srs) {\n    // If web mercator provided reproject to WGS84.\n    if (srs === '900913') {\n        bbox = this.convert(bbox, 'WGS84');\n    }\n\n    var ll = [bbox[0], bbox[1]]; // lower left\n    var ur = [bbox[2], bbox[3]]; // upper right\n    var px_ll = this.px(ll, zoom);\n    var px_ur = this.px(ur, zoom);\n    // Y = 0 for XYZ is the top hence minY uses px_ur[1].\n    var bounds = {\n        minX: Math.floor(px_ll[0] / this.size),\n        minY: Math.floor(px_ur[1] / this.size),\n        maxX: Math.floor((px_ur[0] - 1) / this.size),\n        maxY: Math.floor((px_ll[1] - 1) / this.size)\n    };\n    if (tms_style) {\n        var tms = {\n            minY: (Math.pow(2, zoom) - 1) - bounds.maxY,\n            maxY: (Math.pow(2, zoom) - 1) - bounds.minY\n        };\n        bounds.minY = tms.minY;\n        bounds.maxY = tms.maxY;\n    }\n    return bounds;\n};\n\n// Convert projection of given bbox.\n//\n// - `bbox` {Number} bbox in the form `[w, s, e, n]`.\n// - `to` {String} projection of output bbox (WGS84|900913). Input bbox\n//   assumed to be the \"other\" projection.\n// - `@return` {Object} bbox with reprojected coordinates.\nSphericalMercator.prototype.convert = function(bbox, to) {\n    if (to === '900913') {\n        return this.forward(bbox.slice(0, 2)).concat(this.forward(bbox.slice(2,4)));\n    } else {\n        return this.inverse(bbox.slice(0, 2)).concat(this.inverse(bbox.slice(2,4)));\n    }\n};\n\n// Convert lon/lat values to 900913 x/y.\nSphericalMercator.prototype.forward = function(ll) {\n    var xy = [\n        A * ll[0] * D2R,\n        A * Math.log(Math.tan((Math.PI*0.25) + (0.5 * ll[1] * D2R)))\n    ];\n    // if xy value is beyond maxextent (e.g. poles), return maxextent.\n    (xy[0] > MAXEXTENT) && (xy[0] = MAXEXTENT);\n    (xy[0] < -MAXEXTENT) && (xy[0] = -MAXEXTENT);\n    (xy[1] > MAXEXTENT) && (xy[1] = MAXEXTENT);\n    (xy[1] < -MAXEXTENT) && (xy[1] = -MAXEXTENT);\n    return xy;\n};\n\n// Convert 900913 x/y values to lon/lat.\nSphericalMercator.prototype.inverse = function(xy) {\n    return [\n        (xy[0] * R2D / A),\n        ((Math.PI*0.5) - 2.0 * Math.atan(Math.exp(-xy[1] / A))) * R2D\n    ];\n};\n\nreturn SphericalMercator;\n\n})();\n\nif (typeof module !== 'undefined' && typeof exports !== 'undefined') {\n    module.exports = exports = SphericalMercator;\n}\n"
  ]
}